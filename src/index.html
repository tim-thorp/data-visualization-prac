<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Internal vs External Air Quality Comparison</title>
  <style>
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    .chart-grid {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
      margin-top: 20px;
    }
    .chart-container {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 20px;
      background: white;
    }
    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }
    .legend {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 20px;
      margin-bottom: 10px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-box {
      width: 16px;
      height: 16px;
    }
    .legend-external {
      background-color: #1b9e77;
    }
    .legend-internal {
      background-color: #7570b3;
    }
    .missing-data {
      background-color: #f5f5f5;
      border: 1px solid #ddd;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .control-button {
      padding: 8px 16px;
      border: 2px solid #ccc;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    .control-button:hover {
      background: #f0f0f0;
    }
    .control-button.active {
      border-color: #1b9e77;
      background: #1b9e77;
      color: white;
    }
    .bar-label {
      font-size: 12px;
      fill: #666;
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<div class="container">
  <h1>Internal vs External Air Quality Comparison</h1>

  <div class="controls">
    <button class="control-button active" data-pollutant="pm25">PM2.5</button>
    <button class="control-button" data-pollutant="pm10">PM10</button>
    <button class="control-button" data-pollutant="no2">NO₂</button>
  </div>

  <div class="chart-grid">
    <div class="chart-container">
      <div class="legend">
        <div class="legend-item">
          <div class="legend-box legend-external"></div>
          <span id="external-legend">External</span>
        </div>
        <div class="legend-item">
          <div class="legend-box legend-internal"></div>
          <span id="internal-legend">Internal</span>
        </div>
        <div class="legend-item">
          <div class="legend-box missing-data"></div>
          <span>Missing data</span>
        </div>
      </div>
      <svg id="main-chart"></svg>
    </div>

    <div class="chart-container">
      <svg id="bar-chart"></svg>
    </div>
  </div>
  <div class="chart-container" style="margin-top: 20px;">
    <h2 style="text-align: center; margin-bottom: 20px;">Air Quality by Ventilation Method</h2>
    <div class="controls">
      <button class="control-button ventilation-button active" data-ventilation-pollutant="pm1">PM1</button>
      <button class="control-button ventilation-button" data-ventilation-pollutant="pm25">PM2.5</button>
      <button class="control-button ventilation-button" data-ventilation-pollutant="pm5">PM5</button>
      <button class="control-button ventilation-button" data-ventilation-pollutant="pm10">PM10</button>
      <button class="control-button ventilation-button" data-ventilation-pollutant="no2">NO₂</button>
      <button class="control-button ventilation-button" data-ventilation-pollutant="voc">VOC</button>
    </div>
    <svg id="ventilation-chart"></svg>
  </div>
  <div class="chart-container" style="margin-top: 20px;">
    <h2>Air Quality by Time and Day</h2>
    <div class="controls">
      <button class="control-button heatmap-button active" data-heatmap-pollutant="pm25">PM2.5</button>
      <button class="control-button heatmap-button" data-heatmap-pollutant="pm10">PM10</button>
      <button class="control-button heatmap-button" data-heatmap-pollutant="no2">NO₂</button>
    </div>
    <div id="heatmap-container"></div>
  </div>
</div>

<script>
  // In pollutantConfig, add averaging period
  const pollutantConfig = {
    pm25: {
      external: "EXT_PM2.5",
      internal: ["PM2.5_DEVICE_1", "PM2.5_DEVICE_2", "PM2.5_DEVICE_3", "PM2.5_DEVICE_4", "PM2.5_DEVICE_5"],
      label: "PM2.5 (µg/m³)",
      title: "PM2.5 Concentration",
      limits: { who: 15, who_yearly: 5 },  // Updated from who: 10, removed EU limit
      period: "24-hour"
    },
    pm10: {
      external: "EXT_PM10",
      internal: ["PM10_DEVICE_1", "PM10_DEVICE_2", "PM10_DEVICE_3", "PM10_DEVICE_4", "PM10_DEVICE_5"],
      label: "PM10 (µg/m³)",
      title: "PM10 Concentration",
      limits: { who: 45, who_yearly: 15 },  // Updated from who: 20, removed EU limit
      period: "24-hour"
    },
    no2: {
      external: "EXT_NO2",
      internal: ["NO2_DEVICE_1", "NO2_DEVICE_2", "NO2_DEVICE_3", "NO2_DEVICE_4", "NO2_DEVICE_5"],
      label: "NO₂ (µg/m³)",  // Changed from ppb
      title: "NO₂ Concentration",
      limits: { who: 25, who_yearly: 10 },  // Updated from who: 21
      period: "24-hour"  // Changed from 8-hour
    }
  };

  const ventilationPollutantConfig = {
    pm1: {
      internal: ["PM1_DEVICE_1", "PM1_DEVICE_2", "PM1_DEVICE_3", "PM1_DEVICE_4", "PM1_DEVICE_5"],
      label: "PM1 (µg/m³)",
      title: "PM1 Concentration"
    },
    pm25: {
      internal: ["PM2.5_DEVICE_1", "PM2.5_DEVICE_2", "PM2.5_DEVICE_3", "PM2.5_DEVICE_4", "PM2.5_DEVICE_5"],
      label: "PM2.5 (µg/m³)",
      title: "PM2.5 Concentration",
      limits: { who: 15 }
    },
    pm5: {
      internal: ["PM5_DEVICE_1", "PM5_DEVICE_2", "PM5_DEVICE_3", "PM5_DEVICE_4", "PM5_DEVICE_5"],
      label: "PM5 (µg/m³)",
      title: "PM5 Concentration"
    },
    pm10: {
      internal: ["PM10_DEVICE_1", "PM10_DEVICE_2", "PM10_DEVICE_3", "PM10_DEVICE_4", "PM10_DEVICE_5"],
      label: "PM10 (µg/m³)",
      title: "PM10 Concentration",
      limits: { who: 45 }
    },
    no2: {
      internal: ["NO2_DEVICE_1", "NO2_DEVICE_2", "NO2_DEVICE_3", "NO2_DEVICE_4", "NO2_DEVICE_5"],
      label: "NO₂ (µg/m³)",
      title: "NO₂ Concentration",
      limits: { who: 25 }
    },
    voc: {
      internal: ["VOC_DEVICE_1", "VOC_DEVICE_2", "VOC_DEVICE_3", "VOC_DEVICE_4", "VOC_DEVICE_5"],
      label: "VOC (ppm)",
      title: "Volatile Organic Compounds"
    }
  };

  function createBarChart(svgId, processedData, yLabel, config, maxValue) {
    // Clear previous chart
    d3.select("#" + svgId).selectAll("*").remove();

    const margin = {top: 40, right: 30, bottom: 50, left: 60};
    const width = 260 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#" + svgId)
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Calculate averages
    const averages = [
      {
        type: "External",
        value: d3.mean(processedData.map(d => d.external).filter(v => v !== null)),
        color: "#1b9e77"
      },
      {
        type: "Internal",
        value: d3.mean(processedData.map(d => d.internal).filter(v => v !== null)),
        color: "#7570b3"
      }
    ];

    // Create scales
    const x = d3.scaleBand()
            .domain(averages.map(d => d.type))
            .range([0, width])
            .padding(0.3);

    const y = d3.scaleLinear()
            .domain([0, maxValue])
            .range([height, 0]);

    // Add bars
    svg.selectAll(".bar")
            .data(averages)
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", d => x(d.type))
            .attr("y", d => y(d.value))
            .attr("width", x.bandwidth())
            .attr("height", d => height - y(d.value))
            .attr("fill", d => d.color);

    // Add value labels on top of bars
    svg.selectAll(".bar-label")
            .data(averages)
            .enter()
            .append("text")
            .attr("class", "bar-label")
            .attr("x", d => x(d.type) + x.bandwidth() / 2)
            .attr("y", d => y(d.value) - 5)
            .attr("text-anchor", "middle")
            .text(d => d.value.toFixed(1));

    // Add Y axis
    svg.append("g")
            .call(d3.axisLeft(y));

    // Add X axis
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x));

    // Add Y axis label
    svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text(yLabel);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", 0 - margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "14px")
            .text(`Mean Values`);

    if (config.limits?.who_yearly) {
      // Add the horizontal line
      svg.append("line")
              .attr("x1", 0)
              .attr("x2", width)
              .attr("y1", y(config.limits.who_yearly))
              .attr("y2", y(config.limits.who_yearly))
              .attr("stroke", "#d95f02")
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "5,5");

      // Add the label
      svg.append("text")
              .attr("x", width/2)
              .attr("y", y(config.limits.who_yearly) - 5)
              .attr("text-anchor", "middle")
              .attr("fill", "#d95f02")
              .style("font-size", "12px")
              .text(`WHO annual limit`);
    }
  }

  function createLineChart(svgId, data, externalColumn, internalColumns, yLabel, chartTitle, limits, config) {
    // Clear previous chart
    d3.select("#" + svgId).selectAll("*").remove();

    // Update the chart title with the period
    const fullChartTitle = `${chartTitle} (${config.period} rolling mean)`;

    const margin = {top: 40, right: 30, bottom: 50, left: 60};
    const width = 1000 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#" + svgId)
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Process data
    const processedData = data.map(d => {
      // First get median across devices for this timestamp
      const internalValues = internalColumns.map(col => {
        const val = d[col];
        return (val === '' || val === undefined || val === null) ? null : +val;
      }).filter(val => val !== null);

      return {
        date: new Date(d['date_bin']),
        external: (d[externalColumn] === '' || d[externalColumn] === undefined || d[externalColumn] === null) ?
                null : +d[externalColumn],
        internal: internalValues.length >= 2 ? d3.median(internalValues) : null
      };
    }).filter(d => d.date && !isNaN(d.date.getTime()))
            .sort((a, b) => a.date - b.date);

// Calculate rolling averages
    const windowHours = config.period === '8-hour' ? 8 : 24; // 8 hours for NO2, 24 for PM
    const windowMilliseconds = windowHours * 60 * 60 * 1000; // Convert hours to milliseconds

    const rollingAverages = processedData.map((currentPoint, i) => {
      const currentTime = currentPoint.date.getTime();
      let windowStart = i;

      // Find start of window by moving backwards until we're outside the time window
      while (windowStart > 0 &&
      (currentTime - processedData[windowStart - 1].date.getTime()) <= windowMilliseconds) {
        windowStart--;
      }

      // Get window data
      const windowData = processedData.slice(windowStart, i + 1);

      // Calculate time coverage
      const timeSpan = currentTime - windowData[0].date.getTime();
      const coverage = timeSpan / windowMilliseconds;

      // Calculate internal and external averages
      const internal = windowData
              .filter(d => d.internal !== null)
              .map(d => d.internal);

      const external = windowData
              .filter(d => d.external !== null)
              .map(d => d.external);

      return {
        date: currentPoint.date,
        internal: coverage >= 0.75 && internal.length > 0 ?
                d3.mean(internal) : null,
        external: coverage >= 0.75 && external.length > 0 ?
                d3.mean(external) : null
      };
    });

    // Calculate max value for both charts
    const maxValue = Math.max(
            d3.max(rollingAverages, d => d.external || 0),
            d3.max(rollingAverages, d => d.internal || 0),
            limits?.who || 0
    ) * 1.1;

    // Update legend text
    document.getElementById('external-legend').textContent = `External`;
    document.getElementById('internal-legend').textContent = `Internal`;

    // Create bar chart with the processed data
    createBarChart("bar-chart", rollingAverages, yLabel, config, maxValue);

    // Find gaps in data (where either external or internal data is missing)
    const gaps = [];
    let currentGap = null;

    for (let i = 0; i < rollingAverages.length; i++) {
      if (rollingAverages[i].external === null || rollingAverages[i].internal === null) {
        if (!currentGap) {
          currentGap = { start: rollingAverages[i].date };
        }
      } else if (currentGap) {
        currentGap.end = rollingAverages[i].date;
        gaps.push(currentGap);
        currentGap = null;
      }
    }

    if (currentGap) {
      currentGap.end = rollingAverages[rollingAverages.length - 1].date;
      gaps.push(currentGap);
    }

    // Create scales using rolling averages
    const x = d3.scaleTime()
            .domain(d3.extent(rollingAverages, d => d.date))
            .range([0, width]);

    const y = d3.scaleLinear()
            .domain([0, maxValue])
            .range([height, 0]);

    // Add missing data background first (bottom layer)
    svg.selectAll(".gap")
            .data(gaps)
            .enter()
            .append("rect")
            .attr("class", "gap")
            .attr("x", d => x(d.start))
            .attr("y", 0)
            .attr("width", d => x(d.end) - x(d.start))
            .attr("height", height)
            .attr("fill", "#f5f5f5");

    // Create line generators
    const externalLine = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.external))
            .defined(d => d.external !== null);

    const internalLine = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.internal))
            .defined(d => d.internal !== null);

    // Add the external line path
    svg.append("path")
            .datum(rollingAverages)
            .attr("fill", "none")
            .attr("stroke", "#1b9e77")
            .attr("stroke-width", 1.5)
            .attr("d", externalLine);

    svg.append("path")
            .datum(rollingAverages)
            .attr("fill", "none")
            .attr("stroke", "#7570b3")
            .attr("stroke-width", 1.5)
            .attr("d", internalLine);

    // Add X axis
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("transform", "rotate(-45)");

    // Add Y axis
    svg.append("g")
            .call(d3.axisLeft(y));

    // Add Y axis label
    svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text(yLabel);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", 0 - margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text(fullChartTitle);

    // Add WHO guideline line last (top layer)
    if (limits?.who) {
      // Create a group for WHO elements
      const whoGroup = svg.append("g");

      whoGroup.append("line")
              .attr("x1", 0)
              .attr("x2", width)
              .attr("y1", y(limits.who))
              .attr("y2", y(limits.who))
              .attr("stroke", "#d95f02")
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "5,5");

      whoGroup.append("text")
              .attr("x", 5)
              .attr("y", y(limits.who) - 5)
              .attr("fill", "#d95f02")
              .style("font-size", "12px")
              .text("WHO 24-hour limit");
    }
  }

  function createHeatmap(data, config) {
    // Clear previous chart
    d3.select("#heatmap-container").selectAll("*").remove();

    const margin = { top: 40, right: 80, bottom: 60, left: 80 };
    const width = 1000 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#heatmap-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Process data
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const hours = d3.range(24);

    // First, collect all values for each day-hour combination
    const timeData = {};
    data.forEach(d => {
      const date = new Date(d.date_bin);
      const day = days[date.getDay()];
      const hour = date.getHours();

      const values = config.internal
              .map(col => parseFloat(d[col]))
              .filter(val => !isNaN(val));

      if (values.length > 0) {
        const key = `${day}-${hour}`;
        if (!timeData[key]) {
          timeData[key] = [];
        }
        timeData[key] = timeData[key].concat(values);
      }
    });

    // Calculate medians for each time slot
    const heatmapData = [];
    days.forEach(day => {
      hours.forEach(hour => {
        const key = `${day}-${hour}`;
        const values = timeData[key];
        if (values && values.length > 0) {
          heatmapData.push({
            day: day,
            hour: hour,
            value: d3.median(values),
            count: values.length
          });
        }
      });
    });

    // Create scales
    const x = d3.scaleBand()
            .range([0, width])
            .domain(hours)
            .padding(0.01);

    const y = d3.scaleBand()
            .range([0, height])
            .domain(days)
            .padding(0.01);

    // Use 95th percentile for color scale to avoid outlier influence
    const colorScale = d3.scaleSequential()
            .interpolator(d3.interpolateYlOrRd)
            .domain([0, d3.quantile(heatmapData.map(d => d.value), 0.95)]);

    // Create tooltip
    const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

    // Add heatmap cells
    svg.selectAll("rect")
            .data(heatmapData)
            .join("rect")
            .attr("x", d => x(d.hour))
            .attr("y", d => y(d.day))
            .attr("width", x.bandwidth())
            .attr("height", y.bandwidth())
            .style("fill", d => colorScale(d.value))
            .on("mouseover", function(event, d) {
              tooltip.transition()
                      .duration(200)
                      .style("opacity", .9);
              tooltip.html(
                      `${d.day} ${d.hour}:00<br/>` +
                      `Value: ${d.value.toFixed(2)} ${config.label}<br/>` +
                      `Measurements: ${d.count}`
              )
                      .style("left", (event.pageX + 10) + "px")
                      .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function() {
              tooltip.transition()
                      .duration(500)
                      .style("opacity", 0);
            });

    // Add axes
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x).tickFormat(d => `${d}:00`));

    svg.append("g")
            .call(d3.axisLeft(y));

    // Add color legend
    const legendWidth = width / 4;
    const legendHeight = 15;

    const legendScale = d3.scaleLinear()
            .domain(colorScale.domain())
            .range([0, legendWidth]);

    const legendAxis = d3.axisBottom(legendScale)
            .ticks(5)
            .tickFormat(d => d.toFixed(1));

    const legend = svg.append("g")
            .attr("transform", `translate(${width - legendWidth},${height + 40})`);

    // Create gradient for legend
    const defs = svg.append("defs");
    const linearGradient = defs.append("linearGradient")
            .attr("id", "linear-gradient");

    linearGradient.selectAll("stop")
            .data(colorScale.ticks().map((t, i, n) => ({
              offset: `${i/(n.length-1)*100}%`,
              color: colorScale(t)
            })))
            .enter()
            .append("stop")
            .attr("offset", d => d.offset)
            .attr("stop-color", d => d.color);

    legend.append("rect")
            .attr("width", legendWidth)
            .attr("height", legendHeight)
            .style("fill", "url(#linear-gradient)");

    legend.append("g")
            .attr("transform", `translate(0,${legendHeight})`)
            .call(legendAxis);

    // Add legend label
    legend.append("text")
            .attr("x", legendWidth / 2)
            .attr("y", legendHeight + 35)
            .attr("text-anchor", "middle")
            .text(config.label);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", -margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text(`${config.title} by Time and Day`);
  }

  function createViolinBoxPlot(data, config) {
    const margin = {top: 40, right: 60, bottom: 70, left: 80};
    const width = 1000 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    // Clear previous chart
    d3.select("#ventilation-chart").selectAll("*").remove();

    const svg = d3.select("#ventilation-chart")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Process data to get all values for each ventilation type
    const ventData = {};
    const MIN_DURATION = 30; // Minimum duration in minutes

    // Helper function to remove outliers from an array
    function removeOutliers(arr) {
      const q1 = d3.quantile(arr, 0.25);
      const q3 = d3.quantile(arr, 0.75);
      const iqr = q3 - q1;
      const validRange = [q1 - 1.5 * iqr, q3 + 1.5 * iqr];
      return arr.filter(d => d >= validRange[0] && d <= validRange[1]);
    }

    // First pass: collect values that meet the duration threshold
    data.forEach(d => {
      config.internal.forEach((col, idx) => {
        const value = parseFloat(d[col]);
        const ventType = d[`VENT_TYPE_DEVICE_${idx + 1}`];
        const ventTime = d[`VENT_TIME_DEVICE_${idx + 1}`];

        if (!isNaN(value) && ventType && ventType !== "" && ventTime >= MIN_DURATION) {
          if (!ventData[ventType]) {
            ventData[ventType] = [];
          }
          ventData[ventType].push(value);
        }
      });
    });

    // Second pass: remove outliers from each ventilation type
    Object.keys(ventData).forEach(ventType => {
      ventData[ventType] = removeOutliers(ventData[ventType].sort((a, b) => a - b));
    });

    // Calculate medians for sorting
    const ventTypeMedians = Object.entries(ventData).map(([type, values]) => ({
      type: type,
      median: d3.quantile(values, 0.5)
    }));

    // Sort ventilation types by median
    const ventTypes = ventTypeMedians
            .sort((a, b) => a.median - b.median)
            .map(d => d.type);

    // Get all values for scaling
    const allValues = Object.values(ventData).flat();

    // Create scales
    const x = d3.scaleBand()
            .range([0, width])
            .domain(ventTypes)
            .padding(0.2);

    const y = d3.scaleLinear()
            .range([height, 0])
            .domain([0, d3.max(allValues)]);

    // Add X axis
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-45)");

    // Add Y axis
    svg.append("g")
            .call(d3.axisLeft(y));

    // Add Y axis label
    svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text(config.label);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", 0 - margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text(`${config.title} by Ventilation Method (duration ≥ ${MIN_DURATION}min)`);

    // Create violin plots
    ventTypes.forEach(ventType => {
      const values = ventData[ventType];
      const xPos = x(ventType);
      const width = x.bandwidth();

      // Use a fixed bandwidth based on data range and bin count
      const binCount = 50;
      const bandwidth = (y.domain()[1] - y.domain()[0]) / binCount;

      // Generate points for the violin plot
      const violinPoints = [];
      const bins = d3.range(y.domain()[0], y.domain()[1], bandwidth);

      bins.forEach(bin => {
        const count = values.filter(v => v >= bin && v < bin + bandwidth).length;
        violinPoints.push([bin, count / values.length / bandwidth]);
      });

      // Scale violin width
      const maxDensity = d3.max(violinPoints, d => d[1]);
      const violinScale = d3.scaleLinear()
              .domain([0, maxDensity])
              .range([0, width/2]);

      // Draw violin
      const area = d3.area()
              .x0(d => xPos + width/2 - violinScale(d[1]))
              .x1(d => xPos + width/2 + violinScale(d[1]))
              .y(d => y(d[0]))
              .curve(d3.curveBasis);

      svg.append("path")
              .datum(violinPoints)
              .attr("class", "violin")
              .attr("d", area)
              .style("fill", "#e6e6e6")
              .style("opacity", 0.6);

      // Compute box plot statistics
      const q1 = d3.quantile(values, 0.25);
      const median = d3.quantile(values, 0.5);
      const q3 = d3.quantile(values, 0.75);
      const min = d3.min(values);
      const max = d3.max(values);

      // Draw box plot
      // Box
      svg.append("rect")
              .attr("x", xPos + width/4)
              .attr("y", y(q3))
              .attr("width", width/2)
              .attr("height", y(q1) - y(q3))
              .attr("stroke", "black")
              .attr("fill", "#7570b3")
              .attr("opacity", 0.7);

      // Median line
      svg.append("line")
              .attr("x1", xPos + width/4)
              .attr("x2", xPos + 3*width/4)
              .attr("y1", y(median))
              .attr("y2", y(median))
              .attr("stroke", "black")
              .attr("stroke-width", 2);

      // Whiskers
      svg.append("line")
              .attr("x1", xPos + width/2)
              .attr("x2", xPos + width/2)
              .attr("y1", y(min))
              .attr("y2", y(q1))
              .attr("stroke", "black");

      svg.append("line")
              .attr("x1", xPos + width/2)
              .attr("x2", xPos + width/2)
              .attr("y1", y(q3))
              .attr("y2", y(max))
              .attr("stroke", "black");

      // Whisker ends
      svg.append("line")
              .attr("x1", xPos + width/4)
              .attr("x2", xPos + 3*width/4)
              .attr("y1", y(min))
              .attr("y2", y(min))
              .attr("stroke", "black");

      svg.append("line")
              .attr("x1", xPos + width/4)
              .attr("x2", xPos + 3*width/4)
              .attr("y1", y(max))
              .attr("y2", y(max))
              .attr("stroke", "black");
    });
  }

  // Load data and set up toggle functionality
  d3.csv("all_devices_merged.csv")
          .then(function(data) {
            // Initial line and bar charts
            const initialPollutant = "pm25";
            const config = pollutantConfig[initialPollutant];
            createLineChart("main-chart", data,
                    config.external,
                    config.internal,
                    config.label,
                    config.title,
                    config.limits,
                    config
            );

            // Set up main toggle buttons
            d3.selectAll("[data-pollutant]").on("click", function() {
              d3.selectAll("[data-pollutant]").classed("active", false);
              d3.select(this).classed("active", true);
              const pollutant = this.getAttribute("data-pollutant");
              const config = pollutantConfig[pollutant];
              createLineChart("main-chart", data,
                      config.external,
                      config.internal,
                      config.label,
                      config.title,
                      config.limits,
                      config
              );
            });

            // Set up heatmap toggle buttons
            d3.selectAll("[data-heatmap-pollutant]").on("click", function() {
              d3.selectAll("[data-heatmap-pollutant]").classed("active", false);
              d3.select(this).classed("active", true);
              const pollutant = this.getAttribute("data-heatmap-pollutant");
              createHeatmap(data, pollutantConfig[pollutant]);
            });

            // Create initial heatmap
            createHeatmap(data, pollutantConfig["pm25"]);

            // Set up ventilation plot toggle buttons
            d3.selectAll("[data-ventilation-pollutant]").on("click", function() {
              d3.selectAll("[data-ventilation-pollutant]").classed("active", false);
              d3.select(this).classed("active", true);
              const pollutant = this.getAttribute("data-ventilation-pollutant");
              createViolinBoxPlot(data, ventilationPollutantConfig[pollutant]);
            });

            // Create initial ventilation plot
            createViolinBoxPlot(data, ventilationPollutantConfig["pm1"]);
          })
          .catch(function(error) {
            console.error("Error loading the CSV:", error);
            d3.selectAll(".chart-container")
                    .append("p")
                    .style("color", "red")
                    .text("Error loading data. Please check the console for details.");
          });
</script>
</body>
</html>