<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Internal vs External Air Quality Comparison</title>
  <style>
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    .chart-grid {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
      margin-top: 20px;
    }
    .chart-container {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 20px;
      background: white;
    }
    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }
    .legend {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 20px;
      margin-bottom: 10px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-box {
      width: 16px;
      height: 16px;
    }
    .legend-external {
      background-color: #4682b4;
    }
    .legend-internal {
      background-color: #2ca02c;
    }
    .legend-line {
      width: 16px;
      height: 2px;
    }
    .who-line {
      background-color: #ff9800;
    }
    .eu-line {
      background-color: #f44336;
    }
    .missing-data {
      background-color: #f5f5f5;
      border: 1px solid #ddd;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .control-button {
      padding: 8px 16px;
      border: 2px solid #ccc;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    .control-button:hover {
      background: #f0f0f0;
    }
    .control-button.active {
      border-color: #4682b4;
      background: #4682b4;
      color: white;
    }
    .bar-label {
      font-size: 12px;
      fill: #666;
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<div class="container">
  <h1>Internal vs External Air Quality Comparison</h1>

  <div class="controls">
    <button class="control-button active" data-pollutant="pm25">PM2.5</button>
    <button class="control-button" data-pollutant="pm10">PM10</button>
    <button class="control-button" data-pollutant="no2">NO₂</button>
  </div>

  <div class="chart-grid">
    <div class="chart-container">
      <div class="legend">
        <div class="legend-item">
          <div class="legend-box legend-external"></div>
          <span id="external-legend">External</span>
        </div>
        <div class="legend-item">
          <div class="legend-box legend-internal"></div>
          <span id="internal-legend">Internal</span>
        </div>
        <div class="legend-item">
          <div class="legend-box missing-data"></div>
          <span>Missing data</span>
        </div>
        <div class="legend-item">
          <div class="legend-line who-line"></div>
          <span>WHO</span>
        </div>
        <div class="legend-item">
          <div class="legend-line eu-line"></div>
          <span>EU</span>
        </div>
      </div>
      <svg id="main-chart"></svg>
    </div>

    <div class="chart-container">
      <svg id="bar-chart"></svg>
    </div>
  </div>
</div>

<script>
  // In pollutantConfig, add averaging period
  const pollutantConfig = {
    pm25: {
      external: "EXT_PM2.5",
      internal: ["PM2.5_DEVICE_1", "PM2.5_DEVICE_2", "PM2.5_DEVICE_3", "PM2.5_DEVICE_4", "PM2.5_DEVICE_5"],
      label: "PM2.5 (µg/m³)",
      title: "PM2.5 Concentration",
      limits: { who: 10, eu: 25 },
      period: "24-hour"
    },
    pm10: {
      external: "EXT_PM10",
      internal: ["PM10_DEVICE_1", "PM10_DEVICE_2", "PM10_DEVICE_3", "PM10_DEVICE_4", "PM10_DEVICE_5"],
      label: "PM10 (µg/m³)",
      title: "PM10 Concentration",
      limits: { who: 20, eu: 40 },
      period: "24-hour"
    },
    no2: {
      external: "EXT_NO2",
      internal: ["NO2_DEVICE_1", "NO2_DEVICE_2", "NO2_DEVICE_3", "NO2_DEVICE_4", "NO2_DEVICE_5"],
      label: "NO₂ (ppb)",
      title: "NO₂ Concentration",
      limits: { who: 21 },
      period: "8-hour"
    }
  };

  function createBarChart(svgId, processedData, yLabel, config) {
    // Clear previous chart
    d3.select("#" + svgId).selectAll("*").remove();

    const margin = {top: 40, right: 30, bottom: 50, left: 60};
    const width = 260 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#" + svgId)
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Calculate averages
    const averages = [
      {
        type: "External",
        value: d3.median(processedData.map(d => d.external).filter(v => v !== null)),
        color: "#4682b4"
      },
      {
        type: "Internal",
        value: d3.median(processedData.map(d => d.internal).filter(v => v !== null)),
        color: "#2ca02c"
      }
    ];

    // Create scales
    const x = d3.scaleBand()
            .domain(averages.map(d => d.type))
            .range([0, width])
            .padding(0.3);

    const y = d3.scaleLinear()
            .domain([0, d3.max(averages, d => d.value) * 1.1])
            .range([height, 0]);

    // Add bars
    svg.selectAll(".bar")
            .data(averages)
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", d => x(d.type))
            .attr("y", d => y(d.value))
            .attr("width", x.bandwidth())
            .attr("height", d => height - y(d.value))
            .attr("fill", d => d.color);

    // Add value labels on top of bars
    svg.selectAll(".bar-label")
            .data(averages)
            .enter()
            .append("text")
            .attr("class", "bar-label")
            .attr("x", d => x(d.type) + x.bandwidth() / 2)
            .attr("y", d => y(d.value) - 5)
            .attr("text-anchor", "middle")
            .text(d => d.value.toFixed(1));

    // Add Y axis
    svg.append("g")
            .call(d3.axisLeft(y));

    // Add X axis
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x));

    // Add Y axis label
    svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text(yLabel);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", 0 - margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "14px")
            .text(`Median Values (${config.period})`);
  }

  function createLineChart(svgId, data, externalColumn, internalColumns, yLabel, chartTitle, limits, config) {
    // Clear previous chart
    d3.select("#" + svgId).selectAll("*").remove();

    // Update the chart title with the period
    const fullChartTitle = `${chartTitle} (${config.period} rolling mean)`;

    const margin = {top: 40, right: 30, bottom: 50, left: 60};
    const width = 1000 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#" + svgId)
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Process data
    const processedData = data.map(d => {
      // First get median across devices for this timestamp
      const internalValues = internalColumns.map(col => {
        const val = d[col];
        return (val === '' || val === undefined || val === null) ? null : +val;
      }).filter(val => val !== null);

      return {
        date: new Date(d['date_bin']),
        external: (d[externalColumn] === '' || d[externalColumn] === undefined || d[externalColumn] === null) ?
                null : +d[externalColumn],
        internal: internalValues.length >= 2 ? d3.median(internalValues) : null
      };
    }).filter(d => d.date && !isNaN(d.date.getTime()))
            .sort((a, b) => a.date - b.date);

// Calculate rolling averages
    const windowHours = config.period === '8-hour' ? 8 : 24; // 8 hours for NO2, 24 for PM
    const windowMilliseconds = windowHours * 60 * 60 * 1000; // Convert hours to milliseconds

    const rollingAverages = processedData.map((currentPoint, i) => {
      const currentTime = currentPoint.date.getTime();
      let windowStart = i;

      // Find start of window by moving backwards until we're outside the time window
      while (windowStart > 0 &&
      (currentTime - processedData[windowStart - 1].date.getTime()) <= windowMilliseconds) {
        windowStart--;
      }

      // Get window data
      const windowData = processedData.slice(windowStart, i + 1);

      // Calculate time coverage
      const timeSpan = currentTime - windowData[0].date.getTime();
      const coverage = timeSpan / windowMilliseconds;

      // Calculate internal and external averages
      const internal = windowData
              .filter(d => d.internal !== null)
              .map(d => d.internal);

      const external = windowData
              .filter(d => d.external !== null)
              .map(d => d.external);

      return {
        date: currentPoint.date,
        internal: coverage >= 0.75 && internal.length > 0 ?
                d3.mean(internal) : null,
        external: coverage >= 0.75 && external.length > 0 ?
                d3.mean(external) : null
      };
    });

    // Update legend text
    document.getElementById('external-legend').textContent =
            `External (${config.period} mean)`;
    document.getElementById('internal-legend').textContent =
            `Internal (device median, ${config.period} mean)`;

    // Create bar chart with the processed data
    createBarChart("bar-chart", rollingAverages, yLabel, config);

    // Find gaps in data (where either external or internal data is missing)
    const gaps = [];
    let currentGap = null;

    for (let i = 0; i < rollingAverages.length; i++) {
      if (rollingAverages[i].external === null || rollingAverages[i].internal === null) {
        if (!currentGap) {
          currentGap = { start: rollingAverages[i].date };
        }
      } else if (currentGap) {
        currentGap.end = rollingAverages[i].date;
        gaps.push(currentGap);
        currentGap = null;
      }
    }

    if (currentGap) {
      currentGap.end = rollingAverages[rollingAverages.length - 1].date;
      gaps.push(currentGap);
    }

    // Create scales using rolling averages
    const x = d3.scaleTime()
            .domain(d3.extent(rollingAverages, d => d.date))
            .range([0, width]);

    const y = d3.scaleLinear()
            .domain([0, Math.max(
                    d3.max(rollingAverages, d => d.external || 0),
                    d3.max(rollingAverages, d => d.internal || 0),
                    limits?.who || 0,
                    limits?.eu || 0
            ) * 1.1])
            .range([height, 0]);

    // Add missing data background first (bottom layer)
    svg.selectAll(".gap")
            .data(gaps)
            .enter()
            .append("rect")
            .attr("class", "gap")
            .attr("x", d => x(d.start))
            .attr("y", 0)
            .attr("width", d => x(d.end) - x(d.start))
            .attr("height", height)
            .attr("fill", "#f5f5f5");

    // Create line generators
    const externalLine = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.external))
            .defined(d => d.external !== null);

    const internalLine = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.internal))
            .defined(d => d.internal !== null);

    // Add the external line path
    svg.append("path")
            .datum(rollingAverages)
            .attr("fill", "none")
            .attr("stroke", "#4682b4")
            .attr("stroke-width", 1.5)
            .attr("d", externalLine);

    svg.append("path")
            .datum(rollingAverages)
            .attr("fill", "none")
            .attr("stroke", "#2ca02c")
            .attr("stroke-width", 1.5)
            .attr("d", internalLine);

    // Add X axis
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("transform", "rotate(-45)");

    // Add Y axis
    svg.append("g")
            .call(d3.axisLeft(y));

    // Add Y axis label
    svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text(yLabel);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", 0 - margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text(fullChartTitle);

    // Add WHO guideline line last (top layer)
    if (limits?.who) {
      // Create a group for WHO elements
      const whoGroup = svg.append("g");

      whoGroup.append("line")
              .attr("x1", 0)
              .attr("x2", width)
              .attr("y1", y(limits.who))
              .attr("y2", y(limits.who))
              .attr("stroke", "#ff9800")
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "5,5");

      whoGroup.append("text")
              .attr("x", 5)
              .attr("y", y(limits.who) - 5)
              .attr("fill", "#ff9800")
              .style("font-size", "12px")
              .text("WHO");
    }

    // Add EU limit line last (top layer)
    if (limits?.eu && limits.eu !== limits.who) {
      // Create a group for EU elements
      const euGroup = svg.append("g");

      euGroup.append("line")
              .attr("x1", 0)
              .attr("x2", width)
              .attr("y1", y(limits.eu))
              .attr("y2", y(limits.eu))
              .attr("stroke", "#f44336")
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "5,5");

      euGroup.append("text")
              .attr("x", 5)
              .attr("y", y(limits.eu) - 5)
              .attr("fill", "#f44336")
              .style("font-size", "12px")
              .text("EU");
    }
  }

  // Load data and set up toggle functionality
  d3.csv("all_devices_merged.csv")
          .then(function(data) {
            // Initial chart
            const initialPollutant = "pm25";
            const config = pollutantConfig[initialPollutant];
            createLineChart("main-chart", data,
                    config.external,
                    config.internal,
                    config.label,
                    config.title,
                    config.limits,
                    config
            );

            // Set up toggle buttons
            d3.selectAll(".control-button").on("click", function() {
              // Update button styles
              d3.selectAll(".control-button").classed("active", false);
              d3.select(this).classed("active", true);

              // Get selected pollutant and create new chart
              const pollutant = this.getAttribute("data-pollutant");
              const config = pollutantConfig[pollutant];
              createLineChart("main-chart", data,
                      config.external,
                      config.internal,
                      config.label,
                      config.title,
                      config.limits,
                      config
              );
            });
          })
          .catch(function(error) {
            console.error("Error loading the CSV:", error);
            d3.selectAll(".chart-container")
                    .append("p")
                    .style("color", "red")
                    .text("Error loading data. Please check the console for details.");
          });
</script>
</body>
</html>