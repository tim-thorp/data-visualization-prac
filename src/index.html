<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Air Quality Dashboard</title>
  <style>
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    .chart-container {
      position: relative;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 20px;
      background: white;
    }
    .chart-grid {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
      margin-bottom: 20px;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .control-button {
      padding: 8px 16px;
      border: 2px solid #ccc;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    .control-button:hover {
      background: #f0f0f0;
    }
    .control-button.active {
      border-color: #1b9e77;
      background: #1b9e77;
      color: white;
    }
    .tab-container {
      margin-top: 20px;
    }
    .tab-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      border-bottom: 2px solid #ccc;
      padding-bottom: 10px;
    }
    .tab-button {
      padding: 10px 20px;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 16px;
      color: #666;
      position: relative;
    }
    .tab-button:hover {
      color: #1b9e77;
    }
    .tab-button.active {
      color: #1b9e77;
    }
    .tab-button.active::after {
      content: '';
      position: absolute;
      bottom: -12px;
      left: 0;
      width: 100%;
      height: 2px;
      background: #1b9e77;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .legend {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 20px;
      margin-bottom: 0;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-box {
      width: 16px;
      height: 16px;
    }
    .legend-external {
      background-color: #1b9e77;
    }
    .legend-internal {
      background-color: #7570b3;
    }
    .missing-data {
      background-color: #f5f5f5;
      border: 1px solid #ddd;
    }
    .tooltip {
      position: absolute;
      padding: 8px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<div class="container">
  <h1 style="text-align: center; margin-bottom: 30px;">Air Quality Dashboard</h1>

  <div class="tab-container">
    <!-- Tab buttons -->
    <div class="tab-buttons">
      <button class="tab-button active" data-tab="trends">Trends Over Time</button>
      <button class="tab-button" data-tab="ventilation">Ventilation Analysis</button>
      <button class="tab-button" data-tab="patterns">Daily Patterns</button>
    </div>

    <!-- Pollutant selection -->
    <div class="controls">
      <button class="control-button active" data-pollutant="pm25">PM2.5</button>
      <button class="control-button" data-pollutant="pm10">PM10</button>
      <button class="control-button" data-pollutant="no2">NO₂</button>
    </div>

    <!-- Tab content -->
    <div class="tab-content active" id="trends">
      <div class="chart-grid">
        <!-- Line chart -->
        <div class="chart-container">
          <div class="legend">
            <div class="legend-item">
              <div class="legend-box legend-external"></div>
              <span id="external-legend">External</span>
            </div>
            <div class="legend-item">
              <div class="legend-box legend-internal"></div>
              <span id="internal-legend">Internal</span>
            </div>
            <div class="legend-item">
              <div class="legend-box missing-data"></div>
              <span>Missing data</span>
            </div>
          </div>
          <svg id="main-chart"></svg>
        </div>
        <!-- Bar chart -->
        <div class="chart-container">
          <svg id="bar-chart"></svg>
        </div>
      </div>
    </div>

    <div class="tab-content" id="ventilation">
      <div class="chart-container">
        <svg id="ventilation-chart"></svg>
      </div>
    </div>

    <div class="tab-content" id="patterns">
      <div class="chart-container">
        <div id="heatmap-container"></div>
      </div>
    </div>
  </div>
</div>

<script>
  // In pollutantConfig, add averaging period
  const pollutantConfig = {
    pm25: {
      external: "EXT_PM2.5",
      internal: ["PM2.5_DEVICE_1", "PM2.5_DEVICE_2", "PM2.5_DEVICE_3", "PM2.5_DEVICE_4", "PM2.5_DEVICE_5"],
      label: "PM2.5 (µg/m³)",
      title: "PM2.5 Concentration",
      limits: { who: 15, who_yearly: 5 },  // Updated from who: 10, removed EU limit
      period: "24-hour"
    },
    pm10: {
      external: "EXT_PM10",
      internal: ["PM10_DEVICE_1", "PM10_DEVICE_2", "PM10_DEVICE_3", "PM10_DEVICE_4", "PM10_DEVICE_5"],
      label: "PM10 (µg/m³)",
      title: "PM10 Concentration",
      limits: { who: 45, who_yearly: 15 },  // Updated from who: 20, removed EU limit
      period: "24-hour"
    },
    no2: {
      external: "EXT_NO2",
      internal: ["NO2_DEVICE_1", "NO2_DEVICE_2", "NO2_DEVICE_3", "NO2_DEVICE_4", "NO2_DEVICE_5"],
      label: "NO₂ (µg/m³)",  // Changed from ppb
      title: "NO₂ Concentration",
      limits: { who: 25, who_yearly: 10 },  // Updated from who: 21
      period: "24-hour"  // Changed from 8-hour
    }
  };

  const ventilationPollutantConfig = {
    pm25: {
      internal: ["PM2.5_DEVICE_1", "PM2.5_DEVICE_2", "PM2.5_DEVICE_3", "PM2.5_DEVICE_4", "PM2.5_DEVICE_5"],
      label: "PM2.5 (µg/m³)",
      title: "PM2.5 Concentration",
      limits: { who: 15 }
    },
    pm10: {
      internal: ["PM10_DEVICE_1", "PM10_DEVICE_2", "PM10_DEVICE_3", "PM10_DEVICE_4", "PM10_DEVICE_5"],
      label: "PM10 (µg/m³)",
      title: "PM10 Concentration",
      limits: { who: 45 }
    },
    no2: {
      internal: ["NO2_DEVICE_1", "NO2_DEVICE_2", "NO2_DEVICE_3", "NO2_DEVICE_4", "NO2_DEVICE_5"],
      label: "NO₂ (µg/m³)",
      title: "NO₂ Concentration",
      limits: { who: 25 }
    }
  };

  function createBarChart(svgId, processedData, yLabel, config, maxValue) {
    // Clear previous chart
    d3.select("#" + svgId).selectAll("*").remove();

    const margin = {top: 40, right: 30, bottom: 50, left: 60};
    const width = 260 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#" + svgId)
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Calculate averages
    const averages = [
      {
        type: "External",
        value: d3.mean(processedData.map(d => d.external).filter(v => v !== null)),
        color: "#1b9e77"
      },
      {
        type: "Internal",
        value: d3.mean(processedData.map(d => d.internal).filter(v => v !== null)),
        color: "#7570b3"
      }
    ];

    // Create scales
    const x = d3.scaleBand()
            .domain(averages.map(d => d.type))
            .range([0, width])
            .padding(0.3);

    const y = d3.scaleLinear()
            .domain([0, maxValue])
            .range([height, 0]);

    // Add bars
    svg.selectAll(".bar")
            .data(averages)
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", d => x(d.type))
            .attr("y", d => y(d.value))
            .attr("width", x.bandwidth())
            .attr("height", d => height - y(d.value))
            .attr("fill", d => d.color);

    // Add value labels on top of bars
    svg.selectAll(".bar-label")
            .data(averages)
            .enter()
            .append("text")
            .attr("class", "bar-label")
            .attr("x", d => x(d.type) + x.bandwidth() / 2)
            .attr("y", d => y(d.value) - 5)
            .attr("text-anchor", "middle")
            .text(d => d.value.toFixed(1));

    // Add Y axis
    svg.append("g")
            .call(d3.axisLeft(y));

    // Add X axis
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x));

    // Add Y axis label
    svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .text(yLabel);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", 0 - margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "14px")
            .text(`Mean Values`);

    if (config.limits?.who_yearly) {
      // Add the horizontal line
      svg.append("line")
              .attr("x1", 0)
              .attr("x2", width)
              .attr("y1", y(config.limits.who_yearly))
              .attr("y2", y(config.limits.who_yearly))
              .attr("stroke", "#d95f02")
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "5,5");

      // Add the label
      svg.append("text")
              .attr("x", width/2)
              .attr("y", y(config.limits.who_yearly) - 5)
              .attr("text-anchor", "middle")
              .attr("fill", "#d95f02")
              .style("font-size", "12px")
              .text(`WHO annual limit`);
    }
  }

  function createLineChart(svgId, data, externalColumn, internalColumns, yLabel, chartTitle, limits, config) {
    // Clear previous charts
    d3.select("#" + svgId).selectAll("*").remove();
    d3.select("#bar-chart").selectAll("*").remove();

    // Update the chart title with the period
    const fullChartTitle = `${chartTitle} (${config.period} rolling mean)`;

    const margin = {top: 40, right: 30, bottom: 50, left: 60};
    const width = 1000 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#" + svgId)
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Process data
    const processedData = data.map(d => {
      const internalValues = internalColumns.map(col => {
        const val = d[col];
        return (val === '' || val === undefined || val === null) ? null : +val;
      }).filter(val => val !== null);

      return {
        date: new Date(d['date_bin']),
        external: (d[externalColumn] === '' || d[externalColumn] === undefined || d[externalColumn] === null) ?
                null : +d[externalColumn],
        internal: internalValues.length >= 2 ? d3.median(internalValues) : null
      };
    }).filter(d => d.date && !isNaN(d.date.getTime()))
            .sort((a, b) => a.date - b.date);

    // Calculate rolling averages
    const windowHours = config.period === '8-hour' ? 8 : 24;
    const windowMilliseconds = windowHours * 60 * 60 * 1000;

    const rollingAverages = processedData.map((currentPoint, i) => {
      const currentTime = currentPoint.date.getTime();
      let windowStart = i;

      while (windowStart > 0 &&
      (currentTime - processedData[windowStart - 1].date.getTime()) <= windowMilliseconds) {
        windowStart--;
      }

      const windowData = processedData.slice(windowStart, i + 1);
      const timeSpan = currentTime - windowData[0].date.getTime();
      const coverage = timeSpan / windowMilliseconds;

      const internal = windowData
              .filter(d => d.internal !== null)
              .map(d => d.internal);

      const external = windowData
              .filter(d => d.external !== null)
              .map(d => d.external);

      return {
        date: currentPoint.date,
        internal: coverage >= 0.75 && internal.length > 0 ?
                d3.mean(internal) : null,
        external: coverage >= 0.75 && external.length > 0 ?
                d3.mean(external) : null
      };
    });

    // Calculate max value for both charts
    const maxValue = Math.max(
            d3.max(rollingAverages, d => d.external || 0),
            d3.max(rollingAverages, d => d.internal || 0),
            limits?.who || 0
    ) * 1.1;

    // Create tooltip
    const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

    // Find gaps in data
    const gaps = [];
    let currentGap = null;

    for (let i = 0; i < rollingAverages.length; i++) {
      if (rollingAverages[i].external === null || rollingAverages[i].internal === null) {
        if (!currentGap) {
          currentGap = { start: rollingAverages[i].date };
        }
      } else if (currentGap) {
        currentGap.end = rollingAverages[i].date;
        gaps.push(currentGap);
        currentGap = null;
      }
    }

    if (currentGap) {
      currentGap.end = rollingAverages[rollingAverages.length - 1].date;
      gaps.push(currentGap);
    }

    // Create scales
    const x = d3.scaleTime()
            .domain(d3.extent(rollingAverages, d => d.date))
            .range([0, width]);

    const y = d3.scaleLinear()
            .domain([0, maxValue])
            .range([height, 0]);

    // Add missing data background
    svg.selectAll(".gap")
            .data(gaps)
            .enter()
            .append("rect")
            .attr("class", "gap")
            .attr("x", d => x(d.start))
            .attr("y", 0)
            .attr("width", d => x(d.end) - x(d.start))
            .attr("height", height)
            .attr("fill", "#f5f5f5");

    // Create line generators
    const externalLine = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.external))
            .defined(d => d.external !== null);

    const internalLine = d3.line()
            .x(d => x(d.date))
            .y(d => y(d.internal))
            .defined(d => d.internal !== null);

    // Add hover effects and tooltip interactions
    const addHoverArea = (data, className, color) => {
      svg.append("path")
              .datum(data)
              .attr("class", `hover-area ${className}`)
              .attr("fill", "none")
              .attr("stroke", "transparent")
              .attr("stroke-width", 10)
              .attr("d", className === "external" ? externalLine : internalLine)
              .style("pointer-events", "all")
              .on("mouseover", function() {
                d3.select(`.line-${className}`).style("stroke-width", 3);
              })
              .on("mouseout", function() {
                d3.select(`.line-${className}`).style("stroke-width", 1.5);
                tooltip.style("opacity", 0);
              })
              .on("mousemove", function(event) {
                const [mouseX] = d3.pointer(event);
                const bisectDate = d3.bisector(d => d.date).left;
                const x0 = x.invert(mouseX);
                const i = bisectDate(data, x0, 1);
                const d0 = data[i - 1];
                const d1 = data[i];
                if (!d0 || !d1) return;
                const d = x0 - d0.date > d1.date - x0 ? d1 : d0;
                const value = className === "external" ? d.external : d.internal;

                if (value !== null) {
                  tooltip.style("opacity", 0.9)
                          .html(`Date: ${d.date.toLocaleDateString()}<br/>
                  ${className === "external" ? "External" : "Internal"}: ${value.toFixed(2)} ${yLabel}`)
                          .style("left", (event.pageX + 10) + "px")
                          .style("top", (event.pageY - 28) + "px");
                }
              });
    };

    // Add the external line path
    svg.append("path")
            .datum(rollingAverages)
            .attr("class", "line-external")
            .attr("fill", "none")
            .attr("stroke", "#1b9e77")
            .attr("stroke-width", 1.5)
            .attr("d", externalLine);

    // Add the internal line path
    svg.append("path")
            .datum(rollingAverages)
            .attr("class", "line-internal")
            .attr("fill", "none")
            .attr("stroke", "#7570b3")
            .attr("stroke-width", 1.5)
            .attr("d", internalLine);

    // Add hover areas
    addHoverArea(rollingAverages, "external", "#1b9e77");
    addHoverArea(rollingAverages, "internal", "#7570b3");

    // Add X axis
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("transform", "rotate(-45)");

    // Add Y axis
    svg.append("g")
            .call(d3.axisLeft(y));

    // Add Y axis label
    svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text(yLabel);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", 0 - margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text(fullChartTitle);

    // Add WHO guideline line
    if (limits?.who) {
      const whoGroup = svg.append("g");

      whoGroup.append("line")
              .attr("x1", 0)
              .attr("x2", width)
              .attr("y1", y(limits.who))
              .attr("y2", y(limits.who))
              .attr("stroke", "#d95f02")
              .attr("stroke-width", 2)
              .attr("stroke-dasharray", "5,5");

      whoGroup.append("text")
              .attr("x", 5)
              .attr("y", y(limits.who) - 5)
              .attr("fill", "#d95f02")
              .style("font-size", "12px")
              .text("WHO 24-hour limit");
    }

    // Create the bar chart with the same processed data
    createBarChart("bar-chart", rollingAverages, yLabel, config, maxValue);
  }

  function createHeatmap(data, config) {
    // Clear previous chart
    d3.select("#heatmap-container").selectAll("*").remove();

    const margin = { top: 40, right: 80, bottom: 60, left: 80 };
    const width = 1000 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#heatmap-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Process data
    // Reorder days to start with Monday
    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    const hours = d3.range(24);

    // First, collect values for each device separately for each day-hour combination
    const timeData = {};
    data.forEach(d => {
      const date = new Date(d.date_bin);
      let dayIndex = date.getDay() - 1;
      if (dayIndex < 0) dayIndex = 6;
      const day = days[dayIndex];
      const hour = date.getHours();
      const key = `${day}-${hour}`;

      if (!timeData[key]) {
        timeData[key] = {
          deviceValues: Array(config.internal.length).fill([])
        };
      }

      // Collect values for each device separately
      config.internal.forEach((col, deviceIndex) => {
        const value = parseFloat(d[col]);
        if (!isNaN(value)) {
          timeData[key].deviceValues[deviceIndex] =
                  timeData[key].deviceValues[deviceIndex].concat(value);
        }
      });
    });

    // Calculate medians for each time slot, requiring all devices to have data
    const heatmapData = [];
    days.forEach(day => {
      hours.forEach(hour => {
        const key = `${day}-${hour}`;
        const timeSlot = timeData[key];

        if (timeSlot) {
          // Check if all devices have data
          const hasAllDevices = timeSlot.deviceValues.every(deviceData => deviceData.length > 0);

          if (hasAllDevices) {
            // Calculate median for each device first
            const deviceMedians = timeSlot.deviceValues.map(deviceData =>
                    d3.median(deviceData)
            );

            // Then take the median of the device medians
            const overallMedian = d3.median(deviceMedians);

            heatmapData.push({
              day: day,
              hour: hour,
              value: overallMedian,
              count: timeSlot.deviceValues.length // Now represents number of devices
            });
          }
        }
      });
    });

    // Create scales
    const x = d3.scaleBand()
            .range([0, width])
            .domain(hours)
            .padding(0.01);

    const y = d3.scaleBand()
            .range([0, height])
            .domain(days)
            .padding(0.01);

    // Create color scale specific to this pollutant's data
    const colorScale = d3.scaleSequential()
            .interpolator(t => d3.interpolate("#ffffff", "#7570b3")(t))
            .domain([
              d3.min(heatmapData, d => d.value),
              d3.quantile(heatmapData.map(d => d.value), 0.95)
            ]);

    // Create tooltip
    const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

    // Add heatmap cells
    svg.selectAll("rect")
            .data(heatmapData)
            .join("rect")
            .attr("x", d => x(d.hour))
            .attr("y", d => y(d.day))
            .attr("width", x.bandwidth())
            .attr("height", y.bandwidth())
            .style("fill", d => colorScale(d.value))
            .on("mouseover", function(event, d) {
              tooltip.transition()
                      .duration(200)
                      .style("opacity", .9);
              tooltip.html(
                      `${d.day} ${d.hour}:00<br/>` +
                      `Value: ${d.value.toFixed(2)} ${config.label}<br/>` +
                      `Measurements: ${d.count}`
              )
                      .style("left", (event.pageX + 10) + "px")
                      .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function() {
              tooltip.transition()
                      .duration(500)
                      .style("opacity", 0);
            });

    // Add axes
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x).tickFormat(d => `${d}:00`));

    svg.append("g")
            .call(d3.axisLeft(y));

    // Add color legend
    const legendWidth = width / 4;
    const legendHeight = 15;

    const legendScale = d3.scaleLinear()
            .domain(colorScale.domain())
            .range([0, legendWidth]);

    const legendAxis = d3.axisBottom(legendScale)
            .ticks(5)
            .tickFormat(d => d.toFixed(1));

    const legend = svg.append("g")
            .attr("transform", `translate(${width - legendWidth},${height + 40})`);

    // Create gradient for legend
    const defs = svg.append("defs");
    const linearGradient = defs.append("linearGradient")
            .attr("id", "linear-gradient");

    linearGradient.selectAll("stop")
            .data(colorScale.ticks().map((t, i, n) => ({
              offset: `${i/(n.length-1)*100}%`,
              color: colorScale(t)
            })))
            .enter()
            .append("stop")
            .attr("offset", d => d.offset)
            .attr("stop-color", d => d.color);

    legend.append("rect")
            .attr("width", legendWidth)
            .attr("height", legendHeight)
            .style("fill", "url(#linear-gradient)");

    legend.append("g")
            .attr("transform", `translate(0,${legendHeight})`)
            .call(legendAxis);

    // Add legend label
    legend.append("text")
            .attr("x", legendWidth / 2)
            .attr("y", legendHeight + 35)
            .attr("text-anchor", "middle")
            .text(config.label);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", -margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text(`${config.title} by Time and Day`);
  }

  function createViolinBoxPlot(data, config) {
    const margin = {top: 40, right: 60, bottom: 70, left: 80};
    const width = 1000 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    // Clear previous chart
    d3.select("#ventilation-chart").selectAll("*").remove();

    const svg = d3.select("#ventilation-chart")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

    // Process data to get values for each device and ventilation type
    const MIN_DURATION = 30; // Minimum duration in minutes
    const ventData = {};

    // First pass: organize data by ventilation type and device
    data.forEach(d => {
      config.internal.forEach((col, deviceIndex) => {
        const value = parseFloat(d[col]);
        const ventType = d[`VENT_TYPE_DEVICE_${deviceIndex + 1}`];
        const ventTime = d[`VENT_TIME_DEVICE_${deviceIndex + 1}`];

        if (!isNaN(value) && ventType && ventType !== "" && ventTime >= MIN_DURATION) {
          if (!ventData[ventType]) {
            ventData[ventType] = Array(config.internal.length).fill().map(() => []);
          }
          ventData[ventType][deviceIndex].push(value);
        }
      });
    });

    // Helper function to remove outliers from an array
    function removeOutliers(arr) {
      if (arr.length === 0) return arr;
      const q1 = d3.quantile(arr.sort(d3.ascending), 0.25);
      const q3 = d3.quantile(arr.sort(d3.ascending), 0.75);
      const iqr = q3 - q1;
      const validRange = [q1 - 1.5 * iqr, q3 + 1.5 * iqr];
      return arr.filter(d => d >= validRange[0] && d <= validRange[1]);
    }

    // Process data: remove outliers and calculate device medians
    const processedVentData = {};
    Object.entries(ventData).forEach(([ventType, deviceArrays]) => {
      // Check if we have data from all devices
      const hasAllDevices = deviceArrays.every(arr => arr.length > 0);

      if (hasAllDevices) {
        // Remove outliers for each device separately
        const cleanedDeviceArrays = deviceArrays.map(arr => removeOutliers(arr));

        // Store processed data
        processedVentData[ventType] = cleanedDeviceArrays.map(arr => arr.sort(d3.ascending));
      }
    });

    // Use fixed order for ventilation types
    const ventTypes = ["no ventilation", "1 window", "2 windows"];

    // Get all values for scaling
    const allValues = Object.values(processedVentData)
            .flat(2);

    // Create scales
    const x = d3.scaleBand()
            .range([0, width])
            .domain(ventTypes)
            .padding(0.2);

    const y = d3.scaleLinear()
            .range([height, 0])
            .domain([0, d3.max(allValues)]);

    // Add X axis
    svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .selectAll("text")
            .style("text-anchor", "middle");

    // Add Y axis
    svg.append("g")
            .call(d3.axisLeft(y));

    // Add Y axis label
    svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text(config.label);

    // Add title
    svg.append("text")
            .attr("x", width / 2)
            .attr("y", 0 - margin.top / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text(`${config.title} by Ventilation Method (duration ≥ ${MIN_DURATION}min)`);

    // Create violin plots
    ventTypes.forEach(ventType => {
      const deviceArrays = processedVentData[ventType];
      const xPos = x(ventType);
      const width = x.bandwidth();

      // Combine data from all devices, but weight them equally
      const combinedValues = [];
      const deviceSampleSize = Math.min(...deviceArrays.map(arr => arr.length));

      deviceArrays.forEach(deviceData => {
        // Sample equal number of points from each device
        const sampledData = d3.shuffle(deviceData)
                .slice(0, deviceSampleSize);
        combinedValues.push(...sampledData);
      });

      // Use a fixed bandwidth based on data range and bin count
      const binCount = 50;
      const bandwidth = (y.domain()[1] - y.domain()[0]) / binCount;

      // Generate points for the violin plot
      const violinPoints = [];
      const bins = d3.range(y.domain()[0], y.domain()[1], bandwidth);

      bins.forEach(bin => {
        const count = combinedValues.filter(v => v >= bin && v < bin + bandwidth).length;
        violinPoints.push([bin, count / combinedValues.length / bandwidth]);
      });

      // Scale violin width
      const maxDensity = d3.max(violinPoints, d => d[1]);
      const violinScale = d3.scaleLinear()
              .domain([0, maxDensity])
              .range([0, width/2]);

      // Draw violin
      const area = d3.area()
              .x0(d => xPos + width/2 - violinScale(d[1]))
              .x1(d => xPos + width/2 + violinScale(d[1]))
              .y(d => y(d[0]))
              .curve(d3.curveBasis);

      svg.append("path")
              .datum(violinPoints)
              .attr("class", "violin")
              .attr("d", area)
              .style("fill", "#e6e6e6")
              .style("opacity", 0.6);

      // Calculate box plot statistics from the equal-weighted combined data
      const q1 = d3.quantile(combinedValues, 0.25);
      const median = d3.quantile(combinedValues, 0.5);
      const q3 = d3.quantile(combinedValues, 0.75);
      const min = d3.min(combinedValues);
      const max = d3.max(combinedValues);

      // Draw box plot
      // Box
      svg.append("rect")
              .attr("x", xPos + width/4)
              .attr("y", y(q3))
              .attr("width", width/2)
              .attr("height", y(q1) - y(q3))
              .attr("stroke", "black")
              .attr("fill", "#7570b3")
              .attr("opacity", 0.7);

      // Median line
      svg.append("line")
              .attr("x1", xPos + width/4)
              .attr("x2", xPos + 3*width/4)
              .attr("y1", y(median))
              .attr("y2", y(median))
              .attr("stroke", "black")
              .attr("stroke-width", 2);

      // Whiskers
      svg.append("line")
              .attr("x1", xPos + width/2)
              .attr("x2", xPos + width/2)
              .attr("y1", y(min))
              .attr("y2", y(q1))
              .attr("stroke", "black");

      svg.append("line")
              .attr("x1", xPos + width/2)
              .attr("x2", xPos + width/2)
              .attr("y1", y(q3))
              .attr("y2", y(max))
              .attr("stroke", "black");

      // Whisker ends
      svg.append("line")
              .attr("x1", xPos + width/4)
              .attr("x2", xPos + 3*width/4)
              .attr("y1", y(min))
              .attr("y2", y(min))
              .attr("stroke", "black");

      svg.append("line")
              .attr("x1", xPos + width/4)
              .attr("x2", xPos + 3*width/4)
              .attr("y1", y(max))
              .attr("y2", y(max))
              .attr("stroke", "black");
    });
  }

  document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
      // Update active tab button
      document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');

      // Update active tab content
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById(button.dataset.tab).classList.add('active');

      // Update available pollutant options based on tab
      const pollutantButtons = document.querySelectorAll('.control-button');
      pollutantButtons.forEach(btn => {
        const pollutant = btn.dataset.pollutant;
        btn.style.display = ['pm25', 'pm10', 'no2'].includes(pollutant) ? 'block' : 'none';
      });

      // Ensure an active pollutant button is selected
      const anyActiveButton = Array.from(pollutantButtons).some(btn =>
              btn.classList.contains('active') && btn.style.display !== 'none'
      );
      if (!anyActiveButton) {
        const firstVisibleButton = Array.from(pollutantButtons).find(btn =>
                btn.style.display !== 'none'
        );
        if (firstVisibleButton) {
          pollutantButtons.forEach(btn => btn.classList.remove('active'));
          firstVisibleButton.classList.add('active');
        }
      }

      // Update visualization based on current selections
      updateVisualization();
    });
  });

  // Add pollutant selection logic
  document.querySelectorAll('.control-button').forEach(button => {
    button.addEventListener('click', () => {
      document.querySelectorAll('.control-button').forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');
      updateVisualization();
    });
  });

  function updateVisualization() {
    const activeTab = document.querySelector('.tab-button.active').dataset.tab;
    const activePollutant = document.querySelector('.control-button.active').dataset.pollutant;

    // Load data and create appropriate visualization
    d3.csv("all_devices_merged.csv").then(data => {
      switch(activeTab) {
        case 'trends':
          const config = pollutantConfig[activePollutant];
          createLineChart("main-chart", data, config.external, config.internal,
                  config.label, config.title, config.limits, config);
          break;
        case 'ventilation':
          createViolinBoxPlot(data, ventilationPollutantConfig[activePollutant]);
          break;
        case 'patterns':
          createHeatmap(data, pollutantConfig[activePollutant]);
          break;
      }
    });
  }

  // Initial visualization
  updateVisualization();
</script>
</body>
</html>